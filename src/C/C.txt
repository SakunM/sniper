スナイパードメインのCによる実装				A:\PJ\sniper\src\c\c.txt

やっぱCは一味も二味も違う言語だね！！
前回の実装では、記録が無い。あまりにも原始過ぎて応用が思い付かなかったのだろう。構造体にしてもマップの実装にしても・・
また、ヒープ領域が絡むとエラーの原因が付きにくいのも、実装の進展を妨げるので、
今回はUtilsもドメインもmallocをすべて排斥してみた。これで、少なくともヒープメモリーエラーからは隔離される。
そのうえで、原因不明のエラーに対応する。今までもdevelopで連続テストを行うと不確定に落ちていた・・
この辺を徹底的にチェックすると、キャラクタの色設定や細かいところでmallocが使われて断片化の原因になっていたみたいだし、
ファイル読み込みもすべてマイバック戦略を取ってみた。つまり、暫くはオールスタックプログラミングだ。

そうしてみると今まで、原因不明のエラーをmallocのせいにして来た。とくに5件連続のテストが3件目や4件目で落ちるなど・・
何となく、メモリー系のエラーのように感じていたけど、スタックプログラミングにこだわると真実が見えて来た。
今回は日本語のテスト説明が出来る事を良い事にかなり詳細な説明を付けていたけど、tester.c側で桁合わせのために
きめたブロックサイズをオーバーするコメントがあってそこで、オーバーランしていたみたいだ。
もちろん、細かいmallocの使用による細分化で起きたエラーもあったかもしれないけど、これからの方針としてスタックオーバーフロウが
起きない限り、スタックプログラミングに徹する。

他の言語で当たり前のように使っていた構造体だけど、今回のアプリの仕様で本当に必要なのか疑問に思った。
仕様を突き詰めるとメッセージは一回だけ届いて、そのメッセージを一回だけ処理して返すだけなので、構造をキャッシュする必要は無い。

結局SniperとTranslatorは構造体にはしなかった。なので、各関数へは引数が多い。

でも、マイバック戦略でスタックのみを使うので、不可解なメモリエラーを排除できたので、少し自信が持てる。



今回の最終形				 					A:\PJ\mamo2\langs\groovy\prjs\books\ant
現在の作業フォルダ　							A:\PJ\sniper
スナイパーファイナルリードミー					A:\PJ\sniper\readme.txt
スナイパードメインのJavaScriptによる実装		A:\PJ\sniper\src\js\js.txt
スナイパードメインのPythonによる実装			A:\PJ\sniper\src\python\python.txt
スナイパードメインのRubyによる実装				A:\PJ\sniper\src\ruby\ruby.txt
スナイパードメインのHaskellによる実装			A:\PJ\sniper\src\haskell\heskell.txt
スナイパードメインのOCamlによる実装				A:\PJ\sniper\src\ocaml\ocaml.txt
スナイパードメインのC++による実装				A:\PJ\sniper\src\cpp\cpp.txt
スナイパードメインのCによる実装					A:\PJ\sniper\src\c\c.txt
スナイパードメインのRustによる実装				A:\PJ\sniper\src\rust\rust.txt

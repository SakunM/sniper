スナイパーファイナル　　			A:\PJ\sniper\Sniper.txt


「実践テスト駆動開発」は2012年に発行、自分が始めて出会った時期は2017年でそのころの開発環境はNetBeanだった。
大変興味深い内容なので、開発環境をVSCodeに変えて再実装してみる。ただし、使用ライブラリについては2017年当時の物を使う。

VSCodeは、色々な言語に対応するためにJavaに特化したbulid.xmlの自動作成の機能は存在しない。
なので、ビルドツールが必要だ、Javaの場合は昔はAnt、今ならGradleだろうけど、自分はGroovyのMarkupBuilderを使う。
なぜ、MarkupBuilderなのか			A:\PJ\sniper\hint.txt	

スナイパードメインのJavaScriptによる実装		A:\PJ\sniper\src\js\js.txt
スナイパードメインのPythonによる実装			A:\PJ\sniper\src\python\python.txt
スナイパードメインのRubyによる実装			A:\PJ\sniper\src\ruby\ruby.txt
スナイパードメインのHaskellによる実装		A:\PJ\sniper\src\haskell\heskell.txt


本書の提案通り、まずはテスト環境の足場作りだ。FakeAuctionはtest.auctionパッケージの置く、けどサーバーの実装は
main.auctionにAuctionServerとして置き。FakeAuctionからの遠隔操作とした。また、本書ではテスト基盤として
FakeAuctionとApplicationRunnerを実装するけど、自分はApplicationRunnerはMainTestの一部として実装する。
テスト環境の足場作りについて		A:\PJ\sniper\hint.txt

第11章　最初のテストを通す 第12章　入札を準備する：
イテレーションゼロの構築は大変だ。サードパーティーが提供する機能と自前部分の整合性を計る。つまり、実現可能性の検証だ。
Swingを使って提供するGUIの機能を外側から操作するテスト基盤と自前部分の整合性もイテレーションゼロで確かめたい。
つまり、基盤作りの作業量が大きいので、自前部分は極力実現可能性を担保するものの機能は最小限に押さえたい。
まずは、仮想オークションとの送受信の確立（送信内容は最小限）、送受信によって起こる入札状態の変化はGUIで行うので、
そのチェックをWLで行う。イテレーションゼロではWLが自前のGUIを認識するかどうかにとどめる。
この実現可能性を担保しながら、自前部分の実装をどこまでシンプルに行うかが、イテレーションゼロ合否の鍵だと言っている。
ここまでの本書でも実装は第11章で行っているので、プロジェクトでも	A:\PJ\sniper\SnapShots\sec11	に置く。


第12章　入札を準備する：　前章でサードパーティーとの連携を確保したので、いよいよドメイン部分を作っていくけど、
本書では一貫して失敗するテストから始める。入札に参加するけど、入札中にオークションが閉まれば落札失敗になるシナリオだ。
入札中になるためには、オークションに対して、参加要請のメッセージを送り返信として商品の価格情報を受け取る必要がある。
つまり、受信するメッセージの内容に関して理解する必要が有るという事だ、そこでTranslatorを導入してXMPPの窓口に据える。
送信内容に関しては、仮想オークション側で単純な文字列比較で対応する事が出来るだろう。

本書の特徴として、大きなループで回るMainTestを中心に、たとえMainTestが通らなく状態で、そのテストを通すために役割を抽出して、
そのクラスの実装のためにテストを行う事だ。つまり入れ子のテストループだ。
なので、12章ではMainTestは通らない状態で13章に移る事になる　	A:\PJ\sniper\SnapShots\sec12


第13章　スナイパーが入札する：　ここではいよいよドメインの中枢、Sniperを抽出する。ただしE2Eテストは相変わらす失敗する。
本書の特徴的な実装スタイルは、役割同士の結合に必ずインターフェースを挟む事だろう。そしてインターフェースをモックして、
ユニットテストを行う。そのようにしてお互いの関係を疎に保つ。これが徐々に機能を追加していく本書のスタイルに都合が良い。
もう一つ特徴的なスタイルは、ヌルをうまく使う事だ。Translatorの役割はメッセージの解析で、一緒にやってくるhatオブジェクトは
使われる事が無いので、ユニットテストではChatのモックを作るよりもNullを渡している。他にもMainでのChatの生成時も、
リスナーにNullを渡して、生成後に新たなリスナーを渡す事で依存の循環を回避している。そしてようやくE2Eが通る。
しかし、まだ本章はおわらない。オークションに関わる機能とGUIに関わる機能の間にドメイン部分があるようなスタイルに持ち込みたい。
いまはMainの中で混沌としている。最初はオークションに関わる仕事をauctionパッケージのまとめる。
次にSniperListnerの実装はuiパッケージのDisplayerに任せる。Mainは少し整理されたけど、インポートをみるとまだまだだ。
そして、Translatorを整理して、A:\PJ\sniper\hint.txt　　ようやく終了だ。	A:\PJ\sniper\SnapShots\sec13


第14章　スナイパーがオークションで落札する：　　落札する条件はスナイパーの状態が一位入札の時にオークションが終了した場合だ。
なので、まず一位入札中の条件を考えると、オークションからの価格情報のビッダーが自分だった場合という事だ。
当然その場合は追加の買い注文は行わないで、GUIには「一位入札中」と表示するだろう。という事はTranslatorでの、
価格情報の解析でのcurrentPriceメソッドに入札者の情報を含める必要があり。Sniperでは入札者と自分を比べる必要が有るという事だ。

本書では、sniperIdはxmppの詳細だ。なので入札者の比較はTranslatorで行う。異存は無いけどあくまでも一つの設計判断だ。
そしてSniperには自分か自分で無いかの2択だけをSniperListenerのcrrentPriceに乗せる。	A:\PJ\sniper\hint.txt
なので、Sniperでの実装はisWinningという真偽値をcurrentPrice実行時に更新して、auctionClosedで真偽値に応じて、
落札の成否を判断する。SniperListenerのメソッドは、４つに膨らんだけど、現在の機能なら問題ない。 A:\PJ\sniper\SnapShots\sec14


第15章　実際のユーザーインターフェースに向けて：　　現在のGUIは単純なラベルに入札の状態だけを表示していた。
それに、扱う商品も複数の商品に対応したいけど、今は単品だ。将来にむけてGUIを進化させる事が今回のミッションだ。
複数商品の入札の状態を詳細に表すならラベルを増やすよりテーブルを導入する。
ここに来て原因不明でテーブルが表示出来ない現象に見舞われる。エラーメッセージの内容からどこかのライブラリが内部で呼んでいる
hamcrestのメソッドが見つからないみたいだ。結局原因が分からず。A:\SniperAgein\ant15　の内容に差し替えるとうまくいく。
そこで、色々差し替えてみると、原因はant.groovyのpathelementにある事が判明。
まず、antではライブラリ名のスペルミスをチェックしない。また、ライブラリ同士の依存関係がある場合依存するライブラリを後に宣言する
この手のエラーはかなり厳しい	A:\PJ\sniper\hint.txt			A:\PJ\sniper\SnapShots\sec15


第16章　複数の商品をスナイプする：　　いよいよ、複数の商品の入札を扱う。Guiは前章でテーブルを導入したので比較的簡単に思える。
アプリの起動自体がE2Eからの商品名を引数に始めているところも現実的ではないので、GUIへのユーザーの書き込みから始める事も、
この章の後半の機能だ。まず、商品の数だけ必要な機能の洗い出しから始める。でももちろん本書はテストから始める。
自分はhamcrestやMatcherの事がよくわかっていない。複数商品のテストでのメッセージ検証でhasPorpertyを使う事が出来なかった。
他の言語のテストのように、assertThatの第三引数に失敗メッセージを組み合わせる事で対応したかったけど。　　A:\PJ\sniper\hint.txt

いま、前半部分の実装を終えて、後半部分に取り掛かるところだ。前半は引数の配列を利用して複数の商品に対応したけど、
後半ではより実際のアプリに近いGUIから商品を取り込みオークションへ送る戦略に切り替える。これを一つの章にまとめるのは疑問だ。
なので、ここでいったんスナップショットを残す事にする。 A:\PJ\sniper\Snapshots\sec16-1		に残す	A:\PJ\sniper\hint.txt

いよいよ、GUIに大きな変更が加わる。テスト基盤側ではMaon.mainの引数は空にする。GUI側から商品名ももらうからだ。
なので、テスト基盤側ではWLを使ってテキストボックスに商品名を書き込み、参加ボタンを押す。ボタンに紐ずいたアクションで
メインにある無名クラスを起動して、一つであり複数であっても入札を管理できる。　A:\PJ\sniper\Snapshots\sec16-2
この、トリックのような実装は、章の前半で、扱う商品の数が増えても一つで済む機能をMain.mainに戻して、商品の数だけ必要な機能を
joinAuctionに残した事で、joinAuctionをUserListenerでラップする事が簡単に出来た。


第17章　Mainクラスを分解する：　　この章で混沌としたMainクラスを本来の役割であるマッチメーカーに仕上げる。
着手がしやすいのは、XMPP関係なので、こちらから行う。こちらもスナップショットに章を分ける方が良さそうだ。
前半のリファクタリングを終えるとMainクラスからsmack関係のライブラリのインポート宣言が消える。A:\PJ\sniper\Snapshots\sec17-1

後半の目標は、MainとGUIの循環依存の解決のために、UserListenerの実装を抽出する。その名前はLaunchar（ランチャー）発射台だ。
そして入札者の手持ちカバン（Portfolio）も導入して各入札物件（Sniper）を管理保管する場所を見つけた。
なので、Mainのインポート宣言には、GUIの終了時にコネクションを切るためのSwingのイベント関係のライブラリを除いて、
すべて自作のコラボで埋まった。A:\PJ\sniper\Snapshots\sec17-2			A:\PJ\sniper\hint.txt


第18章　詳細を詰める：　現在アプリは追従する他の入札者に高値を付けられた場合、際限なく入札を続ける。ここで入札限度額を導入する
これを逆指値と呼び、逆指値を超えた状態を脱落中と呼び。入札は行わないがオークションの行方は終了まで見守る。

ここで、SniperListnerの4つのメソッドを一つにまとめたような大改修を行う。いままで、アプリの中のいろいろなところで使われている
商品ID（sniperId)を構造化するというアイディアだ、名前はItemとして中に商品IDと入札限度額を持つ。A:\PJ\sniper\hint.txt
この大改修をコンパイラのエラーを手掛かりにMainWindowから始める。A:\PJ\sniper\Snapshots\sec18


第19章　エラー処理：　　へんてこなメッセージをもらったり、一部の情報が抜け落ちたちょっとへんなメッセージを受けたりしたら、
その商品に対する入札は、その時点で中止してその旨をGUIに表示、メッセージの詳細はログファイルに残すように判断した。
でも、同時に進行している他の商品の入札には影響させない事も重要な仕様だ。もちろんここでも失敗するテストから始める。
A:\PJ\sniper\Snapshots\sec19 			A:\PJ\sniper\hint.txt


ここまでは「実践テスト駆動開発」のサンプルコードを解説する章で、以降はテスト駆動開発のかなり高度な話題を扱う。
大変、興味深い話題だけど、チュートリアルとして扱うのは難しい。

新しい試み：　　以降は、新しい試みとして、自分の設計判断でドメインに含めたい処理を抽出。
その部分を違う言語で実装、Java実装部分との通信はテキストファイルで行う。
その変更で、今までのオールJavaのコードも残す事でどのような設計判断をしたのかわかるようにしたい。
具体的には、Mainクラスの　private void addUserListenerFor(AuctionHouse house){ ui.addListener(new Launcher(house, pf));}
を、private void addUserListenerFor(AuctionHouse house){ ui.addListener(new Launcher2(house, pf));}　に変えるだけで、
すべての機能を、新しい機能に差し替えるようにするために少し既存のコードも変更がひつようだ。　A:\PJ\sniper\hint.txt

改変の処理が複雑になった理由の一つに、自分はドメイン部分にメッセージの翻訳の機能も含めたかった事がある。
なので、Sniper2はTranslatorの機能も持ち、XMPPサイドからGUIサイドまで大きく関わる事になる。

送信に使うファイル名はtoSniper.txtで、プロトコルは一行目が現在の入札状態で、2行目がオークションからのメッセージ。
受信に使うファイル名はfromSniper.txtで、プロトコルは、一行目がオークションへの送信メッセージで2行目が新しい入札の状態だ。
状態によって、オークションへの送信はしない場合があるので、その場合の一行目は toAuctionMessage is None になる。

やはり、新しい試みのイテレーションゼロも、やる事は多い。その作業量の多さに遂バグを仕込んでしまった。
文字列のformatで使う%演算子の数が有っていないと例外が出るわけでもなく処理が止まる。でもE2Eテストに特有みたいだ。
ユニットテストでは、java.util.MissingFormatArgumentException: Format specifier '%s'　というエラーで数の違いを教えてくれる。
ただし、formatの引数が多い場合は単純に無視される。E2Eテストの場合内部的な例外はメッセージに現れないみたいだ。
なので、ユニットテストの重要性が増す。


今回の最終形				 	A:\PJ\mamo2\langs\groovy\prjs\books\ant
現在の作業フォルダ　			A:\PJ\sniper



